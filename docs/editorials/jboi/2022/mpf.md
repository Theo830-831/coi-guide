# Maximum Prime Factor
## Problem
Θέλουμε να πάμε από τον αριθμό $Χ$ στο αριθμό $Y$ κάνοντας ένα από τα ακόλουθα operations:

Έστω $p$ ο μεγαλύτερος πρώτος διαιρέτης του $Χ$.
- Να διαιρέσουμε το $Χ$ με το $p$ άρα το $X$ γίνεται $X/p$.
- Να πολλαπλασιάσουμε το $Χ$ με κάποιο πρώτο αριθμό $k$ όπου $p \le k$ άρα το $X$ γίνεται $X k$
### Subtask 1
$1 \le X,Y,Q \le 1000$
Αυτό το subtask λύνεται με dynamic programming και κάποια observations όμως πιστεύω πως αν σκεφτήτε το observations μπορείτε πιο εύκολα να πάρετε τα πρώτα 2 subtasks

### Subtask 2
$1 \le X,Y,Q \le 10^5$

Αν πηγαίνοντας από τον μικρότερο πρώτο αριθμό στον μεγαλύτερο που διαιρεί το $X$ ή to $Y$ (ας τον ονομάζουμε $i$) έστω $a$ η μεγαλύτερη δύναμη του $i$ που διαιρεί το $Χ$ και έστω $b$ η μεγαλύτερη δύναμη του $i$ που διαιρεί το $Y$.

#### Case $1$: $a = b$
Δεν χρειάζεται να διαιρέσουμε/πολλαπλασιάσουμε με κάτι άρα συνεχίζουμε στο επόμενο $i$.

#### Case $2$: $a > b$
Ανγκαστηκά πρέπει να φύγουμε όλους τους πρώτους διαιρέτες του $Χ$ που είναι $> i$ καθώς και $a - b$ φορές το $i$. Όταν τους φύγω θα έχω για όλους τους πρώτους $\le i$ στο $Χ$ τους έχω ίσες φορές με το $Y$ και δεν έχω πρώτο άλλους πρώτους στο $X$ (αφού διαγράφηκαν). Έτσι μπορώ να μετρήσω όλους τους πρώτους αριθμού μεγαλύετρους του i στο $Y$.

Αν μπω μια φορά εδώ σταματάω το loop μου αφού τώρα $Χ = Y$.

#### Case $3$: $a < b$
Ανγκαστηκά πρέπει να φύγουμε όλους τους πρώτους διαιρέτες του $Χ$ που είναι > για να πολλαπλασιάσω το $Χ$ με $b - a$ φορές το $i$. Όταν τους φύγω θα έχω (παρόμοια με το Case $2$)για όλους τους πρώτους $\le i$ στο $Χ$ τους έχω ίσες φορές με το $Y$ και δεν έχω πρώτο άλλους πρώτους στο $X$ (αφού διαγράφηκαν). Έτσι μπορώ να μετρήσω όλους τους πρώτους αριθμού μεγαλύετρους του i στο $Y$.

Αν μπω μια φορά εδώ σταματάω το loop μου αφού τώρα $Χ = Y$.

Τώρα μας μένει να βρούμε τα $i$ και για κάθε $i$ να βρούμε το $a$ και το $b$.

Ο πιο απλός τρόπος είναι αυτός: 

```
set<int>primes //εδώ θα αποθυκεύσουμε όλα τα i
map<int,int>a,b; //εδώ θα αποθυκεύω τα a και b
for(int i = 2;i  * i <= X;i++){
    if(X % i == 0){
        primes.insert(i);
        while(X % i == 0){
            X /= i;
            a[i]++;
        }
    }
}
///Μην ξεχάσετε την περίπτωση που το X δεν έγινε 1
if(X != 1){
    primes.insert(X);
    a[X]++;
}
for(int i = 2;i  * i <= Y;i++){
    if(Y % i == 0){
        primes.insert(i);
        while(Y % i == 0){
            Y /= i;
            b[i]++;
        }
    }
}
if(Y != 1){
    primes.insert(Y);
    a[Y]++;
}
for(auto i:primes){
    ///και κάνουμε τις περιπτώσεις
}
```
Total time complexity: $O(Q \sqrt[]{ΜΑΧVALX})$

### Subtask 3
$1 \le Q \le 10^6$

$1 \le X,Y \le 4\cdot10^6$

To μόνο που θα αλλάξει εδώ θα είναι το τελευταίο κομμάτι. Μπορούμε να κάνουμε μια ποιο advance τεχνική για να βρούμε τον μεγαλύτερο πρώτο διαιρέτη κάθε αριθμού με precalculation.

Αυτό το κόλπο λέγεται sieve of sieve of eratosthenes:

```
int maxprime[MAXN+5] = {0};
maxprime[1] = 1;
for(int i = 2;i <= MAXN;i++){
    if(maxprime[i] == 0){ // εδώ αυτό σημαίνει ότι το i είναι πρώτος
        for(int j = i;j <= MAXN, j += i){
            maxprime[j] = i;
        }
    }
}
```
O συγκεκριμένος κώδικας έχει time complexity: $O(ΜΑΧΝ log(log({MAXN})))$

Γενικά είναι καλό να γνωρίζεται πως $Ν + Ν/2 + Ν/3 + .... + Ν/Ν$ είναι ίσο περίπου με $Ν log N$.

```
int a[MAXN] = {0},b[MAXN] = {0}; //εδώ θα αποθυκεύω τα a και b στο τέλος του κάθε query πρέπει να τα ξαναμηδενίζω αλλά χωρίς να περάσω από άσκοπες θέσεις
set<int>primes //εδώ θα αποθυκεύσουμε όλα τα i
while(X != 1){
    primes.insert(maxprime[X]);
    a[maxprime[X]]++;
    X /= maxprime[X];
}
while(X != 1){
    primes.insert(maxprime[X]);
    a[maxprime[X]]++;
    X /= maxprime[X];
}
for(auto i:primes){
    ///και κάνουμε τις περιπτώσεις
}
///Μηδενίζω το a και το b για να είναι έτοιμα για τα επόμενα queries
for(auto i:primes){
    a[i] = b[i] = 0;
}
```
Total time complexity: $O(Q log{MAXVALX})$
 
